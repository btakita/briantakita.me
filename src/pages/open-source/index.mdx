---
layout: ../../layouts/MarkdownLayout.astro
title: "Open Source"
active: open-source
---
import { atb_, footnote_c_, footnote_list_c_ } from '@btakita/ui--server--blog'
import {
	atb_ado_net_,
	atb_apache2_license_,
	atb_astrojs_,
	atb_backbone_signal_,
	atb_backbonejs_,
	atb_c_sharp_,
	atb_ccrcorp_,
	atb_ctx_core_,
	atb_desertrb_,
	atb_generic_query_analyzer_,
	atb_honk_,
	atb_jasmine_flow_,
	atb_jasminejs_,
	atb_jellyrb_,
	atb_jquery_,
	atb_msaccess_,
	atb_msexcel_,
	atb_naming_convention_,
	atb_nanostores_,
	atb_pivotal_labs_,
	atb_poloniumrb_,
	atb_poof_,
	atb_rr_,
	atb_rspec_,
	atb_ruby_on_rails_,
	atb_rundavoo_,
	atb_screw_unit_,
	atb_smarty_,
	atb_solidjs_,
	atb_svelte_stores_,
	atb_sveltejs_,
	atb_unison_,
	atb_winforms_
} from '@btakita/ui--server--briantakita'
import Rel from '../../components/Rel.astro'
import { mdx__ctx__new } from '../../lib'
export const ctx = mdx__ctx__new()

<p>
	{[
		`I work on open source projects, licensed with the `,
		<Rel dom={atb_apache2_license_()}/>,
		`. I have primarily focused on developing libraries to assist in my project work. I will be focusing on more
		open source components & apps in the near future. Here are some notable projects:`
	]}
</p>

<h2>
	<Rel dom={atb_ctx_core_()}/>
</h2>

<p>
	{[
		`A collection of over 100 general purpose libraries to assist work creating libraries & apps. Development on ctx-core
		begin an 2016 & continues today`,
		<Rel dom={
			footnote_c_({ ctx, id: 'ctx-core--catch-all' },
				`ctx-core has been a bit of a catch-all project to share code between projects under the principles of
				ctx-core. The functionality of ctx-core is in place but the packages need some reorganization &
				documentation is needed to be more widely used. I have used ctx-core to handle transitions between other
				component & state management libraries as they emerge & are updated.`)
		}/>,
		`.`
	]}
</p>

### Motivation

After maintaining several applications, I ran into the issues of:

- quickly creating & iterating on features
- extracting code to reuse
- time to refactor code
- time to upgrade software
- gluing together small libraries & snippets

Using existing solutions such as frameworks or libraries provides the benefit of quickly getting started, however
there is a maintenance burden of:

- large payload size & memory usage
- extending the underlying software to fulfill requirements
- time to upgrade the application with the underlying libraries
- domain language mismatch between the library/framework

<p>
	{[
		`I found that there are usually small libraries & code snippets that can be glued together with a `,
		<Rel dom={
			atb_naming_convention_({ innerText: 'naming convention' })
		}/>,
		` that utilizes unique, immutable, & composable names. As a result, one could find all usages of an entity or
		concept by doing a project-wide search. Rename refactorings were more accurate & comprehensive due to the
		uniqueness of names. Composable naming allows one to understand the context & full description of the entity.`
	]}
</p>

I use ctx-core to maintain software with:

- an accessible domain model
- a flat architecture
- active programming

### Usage

ctx-core uses dependency-injection of a `ctx` `MapCtx|NestedMapCtx` & "beings", (a function created with the `be_`
factory function). The flat architecture reduces incidental complexity. To manage complex domains, Nested architecture
provides scoping. The [Tag Vector](/posts/tag-vector-0-introduction) Convention, created while working on ctx-core,
encodes tags joined by vectors & data structure shapes to express complex domains within a flat architecture.

<p>
	{[
		`Currently, I use ctx-core along with `,
		<Rel dom={atb_nanostores_()}/>,
		` to manage reactive state on the server & the browser. ctx-core is a general purpose library & since nanostores
		is also a general purpose library any component library is supported. In my work, I favor `,
		<Rel dom={atb_solidjs_()}/>,
		` to render components on the server & browser. ctx-core also supports `,
		<Rel dom={atb_sveltejs_()}/>,
		` with `,
		<Rel dom={atb_svelte_stores_()}/>,
		` to render components & manage reactive state on the server & browser.`
	]}
</p>

<h2>
	<Rel dom={atb_nanostores_()}/>
</h2>

<p>
	{[
		`I learned about Nano Stores via `,
		<Rel dom={atb_astrojs_()}/>,
		`. Since I was already using `,
		<Rel dom={atb_svelte_stores_()}/>,
		`, Nano Stores was a natural replacement to support global reactive state while supporting multiple component
		libraries, such as `,
		<Rel dom={atb_solidjs_()}/>,
		`. I contributed a fix`,
		<Rel dom={
			footnote_c_({ ctx, id: 'nanostores-breadth-first-queue' },
				atb_({
					ctx, innerText: 'Nano Stores breadth first queue',
					href: 'https://github.com/nanostores/nanostores/commit/af5ba274b2b400e5b0845b9a187660006faf550f'
				}))
		}/>,
		` to diamond dependency bugs by using a breadth first queuing algorithm which I
		previously contributed to svelte stores`,
		<Rel dom={
			footnote_c_({ ctx, id: 'nanostores-computed-async' },
				atb_({
					ctx, innerText: 'Svelte Cyclic breadth first queue',
					href: 'https://github.com/sveltejs/svelte/commit/4d8090aa158bc369fc679baccb29d7e843bd5ce6'
				}))
		}/>,
		`. I also added soon to be released async support to `,
		<code>computed</code>,
		<Rel dom={
			footnote_c_({ ctx, id: 'nanostores-computed-async' },
				atb_({
					ctx, innerText: 'Nano Stores async computed',
					href: 'https://github.com/nanostores/nanostores/commit/79d02d891f9c5bcf7c5ffffce693d54887df87bc'
				}))
		}/>,
		` & am working on adding autosubsciptions to `,
		<code>computed</code>,
		`.`
	]}
</p>

<h2>
	<Rel dom={atb_backbone_signal_()}/>
</h2>

<p>
	{[
		`I started using global state management with `,
		<Rel dom={atb_backbonejs_()}/>,
		` while Lead Developer at `,
		<Rel dom={atb_honk_()}/>,
		`. I `,
		<a href="/posts/backbone-signal-practical-reactive-programming-javascript">
			created backbone-signal
		</a>,
		` to use global state management with Backbone.js across different projects, while working with `,
		<Rel dom={atb_rundavoo_()}/>,
		`.`,
	]}
</p>

<h2>
	<Rel dom={atb_jasmine_flow_()}/>
</h2>

<p>
	{[
		`While at `,
		<Rel dom={atb_rundavoo_()}/>,
		` I `,
		<a href="/posts/jasmine-flow-fast-and-thourough-testing">created jasmine-flow</a>,
		` to facilitate linear flow testing...saving effort in maintaining automated tests. This was hard-learned
		from maintaining various large apps while at `,
		<Rel dom={atb_honk_()}/>,
		` & `,
		<Rel dom={atb_pivotal_labs_()}/>,
		`.`
	]}
</p>

<h2>
	<Rel dom={atb_rr_()}/>
</h2>

<p>
	{[
		`RR (double Ruby) is a test double library for the Ruby language. I `,
		<a href="/posts/introducing-rr">released RR</a>,
		` back in 2008.
		It features a terse api to for a high signal to syntax noise ratio for read & write friendly automated testing.
		I used global state management to manage complex data interactions. I stopped development when I moved to full-stack
		Javascript development. Maintenance of this project was picked up by `,
		<Rel dom={atb_({ innerText: 'Sutou Kouhei', href: 'https://github.com/kou' })}/>,
		` in 2015.`
	]}
</p>

<h2>
	<Rel dom={atb_rspec_()}/>
</h2>

<p>
	{[
		`I was an early core maintainer on the rspec team. Rspec is the first DSL (Domain Specific Language)
		implementation of `,
		<Rel dom={atb_({
			ctx,
			innerText: 'BDD (Behavioral Driven Development)',
			href: 'https://dannorth.net/introducing-bdd/'
		})}/>,
		`. Key contributions include the first known implementation of nested `,
		<code>describe</code>,
		` & `,
		<code>context</code>,
		` statements`,
		<Rel dom={
			footnote_c_({ ctx, id: 'rspec-nested-describes' },
				`Rspec: Added Nested Describes: Implemented in `,
				atb_({
					ctx,
					innerText: 'two',
					href: 'https://github.com/dchelimsky/rspec/commit/ee2043d08fdea9a1b694fd8d3bf019b85d17ef29'
				}),
				` `,
				atb_({
					ctx,
					innerText: 'commits',
					href: 'https://github.com/dchelimsky/rspec/commit/ee2043d08fdea9a1b694fd8d3bf019b85d17ef29'
				}),
				`.`)
		}/>,
		`. The concept of nested describes was controversial at that time as it was thought it would add to the complexity &
		inhibit readability of the specs. However, nesting `,
		<code>describe</code>,
		` & `,
		<code>context</code>,
		` enabled contextual nesting with separate usage of `,
		<code>beforeEach</code>,
		` & `,
		<code>afterEach</code>,
		`. I championed the idea & delivered the implementation. I also integrated Rspec with `,
		<Rel dom={
			atb_({
				innerText: 'Test::Unit',
				href: 'https://ruby-doc.org/stdlib-3.0.0/libdoc/test-unit/rdoc/Test/Unit.html'
			})
		}/>,
		`, worked on the initial mock implementation, & worked on the `,
		<Rel dom={atb_ruby_on_rails_()}/>,
		` integration.`
	]}
</p>

<h2>
	<Rel dom={atb_desertrb_()}/>
</h2>

Desert is a Rails plugin framework that makes it easy to share models, views, controllers, helpers, routes, and
migrations across your applications.

With Desert, reusability doesn’t come at the cost of extensibility: it’s trivial to extend the functionality of a
plugin - both in your application and in other plugins.

Classes are automatically mixed in with your own or other plugins’ classes. This allows you to make full featured
composable components.

<h2>
	<Rel dom={atb_jellyrb_()}/>
</h2>

<p>
	{[
		`Jelly is an unobtrusive Javascript framework for `,
		<Rel dom={atb_jquery_()}/>,
		` and `,
		<Rel dom={atb_ruby_on_rails_()}/>,
		`. It provides a set of conventions and tools that help you organize your AJAX and client-side code, while
		keeping Javascript out of your views and markup. Jelly is the glue between your Rails controllers and jQuery
		events.`
	]}
</p>
<p>
	{[
		`Jelly encourages and enables unit testing your Javascript code. Using a Javascript testing framework such as `,
		<Rel dom={atb_jasminejs_()}/>,
		` or `,
		<Rel dom={atb_screw_unit_()}/>,
		`, Jelly allows you to test AJAX and client-side events independently from your Rails app.`
	]}
</p>

<h2>
	<Rel dom={atb_poloniumrb_()}/>
</h2>

<p>
	{[
		`Selenium test runner & helpers for Rails. Featured a set of `,
		<code>wait_for</code>,
		` helpers to keep the tests in sync with the application.`
	]}
</p>

<h2>
	<Rel dom={atb_unison_()}/>
</h2>

Reactive in-memory relational caching library which syncs with upstream relational databases. Written in Ruby.

<h2>
	<Rel dom={atb_screw_unit_()}/>
</h2>

Screw.Unit is a Behavior-Driven Testing Framework for Javascript. It features nested describes. Its goals are to
provide:

- a DSL for elegant, readable, organized specs;
- an interactive runner that can execute focused specs and describes;
- and brief, extensible source-code.

<h2>
	<Rel dom={atb_generic_query_analyzer_()}/>
</h2>

<p>
	{[
		`A query analyzer using `,
		<Rel dom={atb_ado_net_()}/>,
		`. I built this tool to run SQL queries on the `,
		<Rel dom={atb_msaccess_()}/>,
		` CRM database & `,
		<Rel dom={atb_msexcel_()}/>,
		` @ `,
		<Rel dom={atb_ccrcorp_()}/>,
		`. Written with `,
		<Rel dom={atb_c_sharp_()}/>,
		`, `,
		<Rel dom={atb_ado_net_()}/>,
		`, `,
		<Rel dom={atb_winforms_()}/>,
		`.`
	]}
</p>

<h2>
	<Rel dom={atb_poof_()}/>
</h2>

<p>
	{[
		`The PHP Object Oriented Framework is a framework library to build components in PHP. It was built as an
		alternative to using the `,
		<Rel dom={atb_smarty_()}/>,
		`. Poof was written to encapsulate html rendering in components.`
	]}
</p>

<Rel dom={footnote_list_c_({ ctx })}/>
