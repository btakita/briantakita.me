---
layout: ../../layouts/MarkdownLayout.astro
title: "Open Source"
active: open-source
---
import { V_atb, V_footnote, V_footnote_list } from '@btakita/ui--server--blog'
import {
	V_atb_ado_net,
	V_atb_apache2_license,
	V_atb_astrojs,
	V_atb_backbone_signal,
	V_atb_backbonejs,
	V_atb_c_sharp,
	V_atb_ccrcorp,
	V_atb_ctx_core,
	V_atb_desertrb,
	V_atb_generic_query_analyzer,
	V_atb_honk,
	V_atb_jasmine_flow,
	V_atb_jasminejs,
	V_atb_jellyrb,
	V_atb_jquery,
	V_atb_msaccess,
	V_atb_msexcel,
	V_atb_naming_convention,
	V_atb_nanostores,
	V_atb_pivotal_labs,
	V_atb_poloniumrb,
	V_atb_poof,
	V_atb_rr,
	V_atb_rspec,
	V_atb_ruby_on_rails,
	V_atb_rundavoo,
	V_atb_screw_unit,
	V_atb_smarty,
	V_atb_solidjs,
	V_atb_svelte_stores,
	V_atb_sveltejs,
	V_atb_unison,
	V_atb_winforms
} from '@btakita/ui--server--briantakita'
import Van from '../../components/Van.astro'
import { mdx__ctx__new } from '../../lib'
export const ctx = mdx__ctx__new()

<p>
	{[
		`I work on open source projects, licensed with the `,
		<Van dom={V_atb_apache2_license({ ctx })}/>,
		`. I have primarily focused on developing libraries to assist in my project work. I will be focusing on more
		open source components & apps in the near future. Here are some notable projects:`
	]}
</p>

<h2>
	<Van dom={V_atb_ctx_core({ ctx })}/>
</h2>

<p>
	{[
		`A collection of over 100 general purpose libraries to assist work creating libraries & apps. Development on ctx-core
		begin an 2016 & continues today`,
		<Van dom={
			V_footnote({ ctx, id: 'ctx-core--catch-all' },
				`ctx-core has been a bit of a catch-all project to share code between projects under the principles of
				ctx-core. The functionality of ctx-core is in place but the packages need some reorganization &
				documentation is needed to be more widely used. I have used ctx-core to handle transitions between other
				component & state management libraries as they emerge & are updated.`)
		}/>,
		`.`
	]}
</p>

### Motivation

After maintaining several applications, I ran into the issues of:

- quickly creating & iterating on features
- extracting code to reuse
- time to refactor code
- time to upgrade software
- gluing together small libraries & snippets

Using existing solutions such as frameworks or libraries provides the benefit of quickly getting started, however
there is a maintenance burden of:

- large payload size & memory usage
- extending the underlying software to fulfill requirements
- time to upgrade the application with the underlying libraries
- domain language mismatch between the library/framework

<p>
	{[
		`I found that there are usually small libraries & code snippets that can be glued together with a `,
		<Van dom={
			V_atb_naming_convention({ ctx, innerText: 'naming convention' })
		}/>,
		` that utilizes unique, immutable, & composable names. As a result, one could find all usages of an entity or
		concept by doing a project-wide search. Rename refactorings were more accurate & comprehensive due to the
		uniqueness of names. Composable naming allows one to understand the context & full description of the entity.`
	]}
</p>

I use ctx-core to maintain software with:

- an accessible domain model
- a flat architecture
- active programming

### Usage

ctx-core uses dependency-injection of a `ctx` `MapCtx|NestedMapCtx` & "beings", (a function created with the `be_`
factory function). The flat architecture reduces incidental complexity. To manage complex domains, Nested architecture
provides scoping. The [Tag Vector](/posts/tag-vector-0-introduction) Convention, created while working on ctx-core,
encodes tags joined by vectors & data structure shapes to express complex domains within a flat architecture.

<p>
	{[
		`Currently, I use ctx-core along with `,
		<Van dom={V_atb_nanostores({ ctx })}/>,
		` to manage reactive state on the server & the browser. ctx-core is a general purpose library & since nanostores
		is also a general purpose library any component library is supported. In my work, I favor `,
		<Van dom={V_atb_solidjs({ ctx })}/>,
		` to render components on the server & browser. ctx-core also supports `,
		<Van dom={V_atb_sveltejs({ ctx })}/>,
		` with `,
		<Van dom={V_atb_svelte_stores({ ctx })}/>,
		` to render components & manage reactive state on the server & browser.`
	]}
</p>

<h2>
	<Van dom={V_atb_nanostores({ ctx })}/>
</h2>

<p>
	{[
		`I learned about Nano Stores via `,
		<Van dom={V_atb_astrojs({ ctx })}/>,
		`. Since I was already using `,
		<Van dom={V_atb_svelte_stores({ ctx })}/>,
		`, Nano Stores was a natural replacement to support global reactive state while supporting multiple component
		libraries, such as `,
		<Van dom={V_atb_solidjs({ ctx })}/>,
		`. I contributed a fix`,
		<Van dom={
			V_footnote({ ctx, id: 'nanostores-breadth-first-queue' },
				V_atb({
					ctx, innerText: 'Nano Stores breadth first queue',
					href: 'https://github.com/nanostores/nanostores/commit/af5ba274b2b400e5b0845b9a187660006faf550f'
				}))
		}/>,
		` to diamond dependency bugs by using a breadth first queuing algorithm which I
		previously contributed to svelte stores`,
		<Van dom={
			V_footnote({ ctx, id: 'nanostores-computed-async' },
				V_atb({
					ctx, innerText: 'Svelte Cyclic breadth first queue',
					href: 'https://github.com/sveltejs/svelte/commit/4d8090aa158bc369fc679baccb29d7e843bd5ce6'
				}))
		}/>,
		`. I also added soon to be released async support to `,
		<code>computed</code>,
		<Van dom={
			V_footnote({ ctx, id: 'nanostores-computed-async' },
				V_atb({
					ctx, innerText: 'Nano Stores async computed',
					href: 'https://github.com/nanostores/nanostores/commit/79d02d891f9c5bcf7c5ffffce693d54887df87bc'
				}))
		}/>,
		` & am working on adding autosubsciptions to `,
		<code>computed</code>,
		`.`
	]}
</p>

<h2>
	<Van dom={V_atb_backbone_signal({ ctx })}/>
</h2>

<p>
	{[
		`I started using global state management with `,
		<Van dom={V_atb_backbonejs({ ctx })}/>,
		` while Lead Developer at `,
		<Van dom={V_atb_honk({ ctx })}/>,
		`. I `,
		<a href="/posts/backbone-signal-practical-reactive-programming-javascript">
			created backbone-signal
		</a>,
		` to use global state management with Backbone.js across different projects, while working with `,
		<Van dom={V_atb_rundavoo({ ctx })}/>,
		`.`,
	]}
</p>

<h2>
	<Van dom={V_atb_jasmine_flow({ ctx })}/>
</h2>

<p>
	{[
		`While at `,
		<Van dom={V_atb_rundavoo({ ctx })}/>,
		` I `,
		<a href="/posts/jasmine-flow-fast-and-thourough-testing">created jasmine-flow</a>,
		` to facilitate linear flow testing...saving effort in maintaining automated tests. This was hard-learned
		from maintaining various large apps while at `,
		<Van dom={V_atb_honk({ ctx })}/>,
		` & `,
		<Van dom={V_atb_pivotal_labs({ ctx })}/>,
		`.`
	]}
</p>

<h2>
	<Van dom={V_atb_rr({ ctx })}/>
</h2>

<p>
	{[
		`RR (double Ruby) is a test double library for the Ruby language. I `,
		<a href="/posts/introducing-rr">released RR</a>,
		` back in 2008.
		It features a terse api to for a high signal to syntax noise ratio for read & write friendly automated testing.
		I used global state management to manage complex data interactions. I stopped development when I moved to full-stack
		Javascript development. Maintenance of this project was picked up by `,
		<Van dom={V_atb({ ctx, innerText: 'Sutou Kouhei', href: 'https://github.com/kou' })}/>,
		` in 2015.`
	]}
</p>

<h2>
	<Van dom={V_atb_rspec({ ctx })}/>
</h2>

<p>
	{[
		`I was an early core maintainer on the rspec team. Rspec is the first DSL (Domain Specific Language)
		implementation of `,
		<Van dom={V_atb({
			ctx,
			innerText: 'BDD (Behavioral Driven Development)',
			href: 'https://dannorth.net/introducing-bdd/'
		})}/>,
		`. Key contributions include the first known implementation of nested `,
		<code>describe</code>,
		` & `,
		<code>context</code>,
		` statements`,
		<Van dom={
			V_footnote({ ctx, id: 'rspec-nested-describes' },
				`Rspec: Added Nested Describes: Implemented in `,
				V_atb({
					ctx,
					innerText: 'two',
					href: 'https://github.com/dchelimsky/rspec/commit/ee2043d08fdea9a1b694fd8d3bf019b85d17ef29'
				}),
				` `,
				V_atb({
					ctx,
					innerText: 'commits',
					href: 'https://github.com/dchelimsky/rspec/commit/ee2043d08fdea9a1b694fd8d3bf019b85d17ef29'
				}),
				`.`)
		}/>,
		`. The concept of nested describes was controversial at that time as it was thought it would add to the complexity &
		inhibit readability of the specs. However, nesting `,
		<code>describe</code>,
		` & `,
		<code>context</code>,
		` enabled contextual nesting with separate usage of `,
		<code>beforeEach</code>,
		` & `,
		<code>afterEach</code>,
		`. I championed the idea & delivered the implementation. I also integrated Rspec with `,
		<Van dom={
			V_atb({
				ctx,
				innerText: 'Test::Unit',
				href: 'https://ruby-doc.org/stdlib-3.0.0/libdoc/test-unit/rdoc/Test/Unit.html'
			})
		}/>,
		`, worked on the initial mock implementation, & worked on the `,
		<Van dom={V_atb_ruby_on_rails({ ctx })}/>,
		` integration.`
	]}
</p>

<h2>
	<Van dom={V_atb_desertrb({ ctx })}/>
</h2>

Desert is a Rails plugin framework that makes it easy to share models, views, controllers, helpers, routes, and
migrations across your applications.

With Desert, reusability doesn’t come at the cost of extensibility: it’s trivial to extend the functionality of a
plugin - both in your application and in other plugins.

Classes are automatically mixed in with your own or other plugins’ classes. This allows you to make full featured
composable components.

<h2>
	<Van dom={V_atb_jellyrb({ ctx })}/>
</h2>

<p>
	{[
		`Jelly is an unobtrusive Javascript framework for `,
		<Van dom={V_atb_jquery({ ctx })}/>,
		` and `,
		<Van dom={V_atb_ruby_on_rails({ ctx })}/>,
		`. It provides a set of conventions and tools that help you organize your AJAX and client-side code, while
		keeping Javascript out of your views and markup. Jelly is the glue between your Rails controllers and jQuery
		events.`
	]}
</p>
<p>
	{[
		`Jelly encourages and enables unit testing your Javascript code. Using a Javascript testing framework such as `,
		<Van dom={V_atb_jasminejs({ ctx })}/>,
		` or `,
		<Van dom={V_atb_screw_unit({ ctx })}/>,
		`, Jelly allows you to test AJAX and client-side events independently from your Rails app.`
	]}
</p>

<h2>
	<Van dom={V_atb_poloniumrb({ ctx })}/>
</h2>

<p>
	{[
		`Selenium test runner & helpers for Rails. Featured a set of `,
		<code>wait_for</code>,
		` helpers to keep the tests in sync with the application.`
	]}
</p>

<h2>
	<Van dom={V_atb_unison({ ctx })}/>
</h2>

Reactive in-memory relational caching library which syncs with upstream relational databases. Written in Ruby.

<h2>
	<Van dom={V_atb_screw_unit({ ctx })}/>
</h2>

Screw.Unit is a Behavior-Driven Testing Framework for Javascript. It features nested describes. Its goals are to
provide:

- a DSL for elegant, readable, organized specs;
- an interactive runner that can execute focused specs and describes;
- and brief, extensible source-code.

<h2>
	<Van dom={V_atb_generic_query_analyzer({ ctx })}/>
</h2>

<p>
	{[
		`A query analyzer using `,
		<Van dom={V_atb_ado_net({ ctx })}/>,
		`. I built this tool to run SQL queries on the `,
		<Van dom={V_atb_msaccess({ ctx })}/>,
		` CRM database & `,
		<Van dom={V_atb_msexcel({ ctx })}/>,
		` @ `,
		<Van dom={V_atb_ccrcorp({ ctx })}/>,
		`. Written with `,
		<Van dom={V_atb_c_sharp({ ctx })}/>,
		`, `,
		<Van dom={V_atb_ado_net({ ctx })}/>,
		`, `,
		<Van dom={V_atb_winforms({ ctx })}/>,
		`.`
	]}
</p>

<h2>
	<Van dom={V_atb_poof({ ctx })}/>
</h2>

<p>
	{[
		`The PHP Object Oriented Framework is a framework library to build components in PHP. It was built as an
		alternative to using the `,
		<Van dom={V_atb_smarty({ ctx })}/>,
		`. Poof was written to encapsulate html rendering in components.`
	]}
</p>

<Van dom={
	V_footnote_list({ ctx })
}/>
