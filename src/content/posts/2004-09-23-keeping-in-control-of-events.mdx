---
author: Brian Takita
pubDate: 2004-09-23T10:27:00Z
title: Keeping in Control of Events
slug: keeping-in-control-of-events
tags:
  - programming
  - dotnet
description:
  At work, I'm having an issue with losing control over events in my code. One big issue I'm having is recursion in
  the `DataRow.RowChanged` event.
---
import { V_fragment } from '@btakita/ui--all--blog'
import { V_atb, V_post_top_note } from '@btakita/ui--server--blog'
import Van from '../../components/Van.astro'
import { mdx__ctx__new } from '../../lib'
export let ctx = mdx__ctx__new()

<Van dom={
	V_post_top_note({ ctx },
	V_fragment({ ctx },
		`Originally posted on `,
		V_atb({
			ctx,
			innerText: 'geekswithblogs.net',
			href: 'https://web.archive.org/web/20130407190636/http://geekswithblogs.net/btakita/archive/2004/09/23/11571.aspx'
		})))
}/>
At work, I'm having an issue with losing control over events in my code. One big issue I'm having is recursion in
the `DataRow.RowChanged` event.

In this case, I'm trying to update the database, during every whenever `e.Action == DataRowAction.Changed`. This also
means having a call to `DataRow.AcceptChanges()` which raises another `DataRowAction.Changed`. I also have instances
when `e.Action == DataRowAction.Changed` but `DataRow.RowState == DataRowState.Unchanged`.

Some thoughts I came up with to try to combat this madness is to...

- Lock the object that fired the event
- Check if the object state matches the event state. If not, throw an exception.
- Implement an event counter.
- Unit test the event count.

What kinds of things do all of you do to keep events under control?
